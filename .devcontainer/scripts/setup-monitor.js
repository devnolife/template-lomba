#!/usr/bin/env node
// ============================================================================
// setup-monitor.js — Post-create / post-attach lifecycle script
// ============================================================================
// Called by devcontainer.json at two lifecycle points:
//   postCreateCommand  — first creation (no flags)
//   postAttachCommand  — every attach  (--attach flag)
//
// Responsibilities:
//   1. Uninstall / block AI-assistance extensions (Copilot, Tabnine, etc.)
//   2. Side-load the contest-monitor VSIX if not already installed
//   3. Inject the monitoring server URL into VS Code settings
//   4. Configure git with participant identity
//   5. Print the contest welcome banner
// ============================================================================

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const os = require('os');

// ---------------------------------------------------------------------------
// Config
// ---------------------------------------------------------------------------

const ATTACH_MODE = process.argv.includes('--attach');

/** Extensions that MUST be removed / prevented from running. */
const BLOCKED_EXTENSIONS = [
  // GitHub Copilot family
  'github.copilot',
  'github.copilot-chat',
  'github.copilot-labs',
  'github.copilot-nightly',

  // Tabnine
  'tabnine.tabnine-vscode',

  // Codeium
  'codeium.codeium',

  // Amazon CodeWhisperer (now Q)
  'amazonwebservices.aws-toolkit-vscode',
  'amazonwebservices.amazon-q-vscode',

  // Sourcegraph Cody
  'sourcegraph.cody-ai',

  // Continue.dev
  'continue.continue',

  // Cursor-like AI
  'anysphere.cursor',

  // Remote SSH / Tunnel (prevent connecting out)
  'ms-vscode-remote.remote-ssh',
  'ms-vscode-remote.remote-ssh-edit',
  'ms-vscode.remote-server',
  'ms-vscode-remote.remote-tunnels',
];

/** Path to the VSIX built from the coding-contest-monitor extension. */
const MONITOR_VSIX_GLOB = path.join(
  __dirname,
  '..',
  '..',
  'coding-contest-monitor',
  '*.vsix',
);

const MONITORING_SERVER =
  process.env.CONTEST_MONITOR_SERVER_URL || 'https://your-server.com';
const PARTICIPANT_ID =
  process.env.PARTICIPANT_ID ||
  process.env.GITHUB_USER ||
  process.env.CODESPACE_NAME ||
  os.userInfo().username;
const CONTEST_MODE = process.env.CONTEST_MODE === 'true';

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/**
 * Run a shell command, swallow errors if `ignoreErrors` is true.
 * @param {string} cmd
 * @param {boolean} [ignoreErrors]
 * @returns {string}
 */
function run(cmd, ignoreErrors = false) {
  try {
    return execSync(cmd, {
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe'],
      timeout: 60_000,
    }).trim();
  } catch (err) {
    if (!ignoreErrors) {
      const msg = err instanceof Error ? err.message : String(err);
      console.error(`  [WARN] Command failed: ${cmd}\n         ${msg}`);
    }
    return '';
  }
}

/** Coloured banner helpers (ANSI). */
const FG = {
  red: (s) => `\x1b[31m${s}\x1b[0m`,
  green: (s) => `\x1b[32m${s}\x1b[0m`,
  yellow: (s) => `\x1b[33m${s}\x1b[0m`,
  cyan: (s) => `\x1b[36m${s}\x1b[0m`,
  bold: (s) => `\x1b[1m${s}\x1b[0m`,
  dim: (s) => `\x1b[2m${s}\x1b[0m`,
};

function heading(text) {
  console.log(`\n${FG.cyan('>>>')} ${FG.bold(text)}`);
}

// ---------------------------------------------------------------------------
// 1. Block / uninstall AI extensions
// ---------------------------------------------------------------------------

function enforceExtensionPolicy() {
  heading('Enforcing extension policy (blocking AI assistants)');

  // Get the list of currently installed extensions.
  const installed = run('code --list-extensions', true)
    .split('\n')
    .map((e) => e.trim().toLowerCase())
    .filter(Boolean);

  let removedCount = 0;

  for (const blocked of BLOCKED_EXTENSIONS) {
    const id = blocked.toLowerCase();
    if (installed.includes(id)) {
      console.log(`  ${FG.red('REMOVING')} ${blocked}`);
      run(`code --uninstall-extension ${blocked} --force`, true);
      removedCount++;
    }
  }

  if (removedCount === 0) {
    console.log(`  ${FG.green('OK')} No blocked extensions found.`);
  } else {
    console.log(
      `  ${FG.yellow('REMOVED')} ${removedCount} blocked extension(s).`,
    );
  }

  // Write a machine-readable blocklist that our monitor extension can also
  // reference at runtime.
  const blocklistPath = path.join(__dirname, '..', 'blocked-extensions.json');
  fs.writeFileSync(
    blocklistPath,
    JSON.stringify(
      {
        _comment:
          'Extensions blocked during contest. This file is auto-generated by setup-monitor.js.',
        blocked: BLOCKED_EXTENSIONS,
        enforcedAt: new Date().toISOString(),
      },
      null,
      2,
    ) + '\n',
  );
  console.log(`  ${FG.dim('Blocklist written to ' + blocklistPath)}`);
}

// ---------------------------------------------------------------------------
// 2. Side-load the contest monitor VSIX
// ---------------------------------------------------------------------------

function installMonitorExtension() {
  heading('Installing contest monitor extension');

  // Check if already installed.
  const installed = run('code --list-extensions', true).toLowerCase();
  if (installed.includes('contest-organizer.coding-contest-monitor')) {
    console.log(`  ${FG.green('OK')} Already installed.`);
    return;
  }

  // Look for a .vsix file in the repo.
  const glob = require('path');
  const contestDir = path.join(__dirname, '..', '..', 'coding-contest-monitor');
  let vsixFile = null;

  try {
    const files = fs.readdirSync(contestDir);
    vsixFile = files.find((f) => f.endsWith('.vsix'));
  } catch {
    // Directory may not exist.
  }

  if (vsixFile) {
    const vsixPath = path.join(contestDir, vsixFile);
    console.log(`  Installing from ${FG.cyan(vsixPath)}`);
    run(`code --install-extension "${vsixPath}" --force`, true);
    console.log(`  ${FG.green('OK')} Extension installed.`);
  } else {
    console.log(
      `  ${FG.yellow('SKIP')} No .vsix found in coding-contest-monitor/.`,
    );
    console.log(
      `         Build it first: cd coding-contest-monitor && npx @vscode/vsce package`,
    );
  }
}

// ---------------------------------------------------------------------------
// 3. Inject monitoring server URL into VS Code settings
// ---------------------------------------------------------------------------

function injectMonitorSettings() {
  heading('Configuring monitoring server URL');

  // VS Code in Codespaces stores user settings at a known path.
  const settingsDirs = [
    path.join(
      os.homedir(),
      '.vscode-remote',
      'data',
      'Machine',
      'settings.json',
    ),
    path.join(
      os.homedir(),
      '.vscode-server',
      'data',
      'Machine',
      'settings.json',
    ),
  ];

  const patch = {
    'codingContestMonitor.serverUrl': MONITORING_SERVER,
    'codingContestMonitor.autoStart': true,
  };

  let written = false;

  for (const settingsPath of settingsDirs) {
    try {
      const dir = path.dirname(settingsPath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }

      let current = {};
      if (fs.existsSync(settingsPath)) {
        try {
          const raw = fs.readFileSync(settingsPath, 'utf-8');
          // Strip trailing commas (common in VS Code jsonc) for safe parsing.
          const cleaned = raw.replace(/,\s*([\]}])/g, '$1');
          current = JSON.parse(cleaned);
        } catch {
          current = {};
        }
      }

      const merged = { ...current, ...patch };
      fs.writeFileSync(settingsPath, JSON.stringify(merged, null, 2) + '\n');
      console.log(`  ${FG.green('OK')} Wrote to ${settingsPath}`);
      written = true;
    } catch {
      // This path may not exist in all environments.
    }
  }

  if (!written) {
    console.log(
      `  ${FG.yellow('NOTE')} Machine settings path not found — server URL will`,
    );
    console.log(
      `         come from CONTEST_MONITOR_SERVER_URL env var instead.`,
    );
  }

  console.log(`  Server URL: ${FG.cyan(MONITORING_SERVER)}`);
}

// ---------------------------------------------------------------------------
// 4. Git configuration
// ---------------------------------------------------------------------------

function configureGit() {
  heading('Configuring git identity');

  const currentName = run('git config --global user.name', true);
  const currentEmail = run('git config --global user.email', true);

  if (!currentName) {
    run(`git config --global user.name "${PARTICIPANT_ID}"`, true);
    console.log(`  user.name  = ${FG.cyan(PARTICIPANT_ID)}`);
  } else {
    console.log(`  user.name  = ${FG.cyan(currentName)} (already set)`);
  }

  if (!currentEmail) {
    const email = `${PARTICIPANT_ID}@contest.local`;
    run(`git config --global user.email "${email}"`, true);
    console.log(`  user.email = ${FG.cyan(email)}`);
  } else {
    console.log(`  user.email = ${FG.cyan(currentEmail)} (already set)`);
  }

  // Tag the initial commit time for forensics.
  const marker = path.join(__dirname, '..', 'contest-start-marker');
  if (!fs.existsSync(marker)) {
    fs.writeFileSync(
      marker,
      JSON.stringify(
        {
          participant: PARTICIPANT_ID,
          startedAt: new Date().toISOString(),
          machineId: process.env.CODESPACE_NAME || os.hostname(),
        },
        null,
        2,
      ) + '\n',
    );
    console.log(`  ${FG.dim('Start marker written to ' + marker)}`);
  }
}

// ---------------------------------------------------------------------------
// 5. Welcome banner
// ---------------------------------------------------------------------------

function printBanner() {
  const line = '='.repeat(56);
  const rules = [
    '1. AI code assistants (Copilot, Tabnine, etc.) are DISABLED.',
    '2. All activity is MONITORED and logged to the server.',
    '3. Do NOT install unauthorized extensions.',
    '4. Switching away from VS Code for >2 min triggers an alert.',
    '5. Copy-paste from external sources is tracked.',
    '6. Write your own code. Good luck!',
  ];

  console.log(`
${FG.cyan(line)}
${FG.bold('  CODING CONTEST ENVIRONMENT')}
${FG.cyan(line)}

  ${FG.dim('Participant:')}  ${FG.bold(PARTICIPANT_ID)}
  ${FG.dim('Server:')}       ${FG.cyan(MONITORING_SERVER)}
  ${FG.dim('Contest mode:')} ${CONTEST_MODE ? FG.green('ENABLED') : FG.yellow('DISABLED')}
  ${FG.dim('Timestamp:')}    ${new Date().toISOString()}

${FG.yellow('  RULES:')}
${rules.map((r) => `  ${FG.dim('>')} ${r}`).join('\n')}

${FG.cyan(line)}
`);
}

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------

function main() {
  console.log(
    FG.dim(
      `\n[setup-monitor] Running in ${ATTACH_MODE ? 'ATTACH' : 'CREATE'} mode...\n`,
    ),
  );

  try {
    // Always enforce the extension policy (on create AND attach).
    enforceExtensionPolicy();

    if (!ATTACH_MODE) {
      // First-time setup only.
      installMonitorExtension();
      configureGit();
    }

    // Always inject settings and show banner.
    injectMonitorSettings();
    printBanner();
  } catch (err) {
    console.error(
      FG.red('\n[setup-monitor] Fatal error during setup:'),
      err instanceof Error ? err.message : err,
    );
    console.error(
      FG.yellow(
        '[setup-monitor] The contest environment may not be fully configured.',
      ),
    );
    // Do NOT exit(1) — we don't want to block Codespace creation.
  }
}

main();
